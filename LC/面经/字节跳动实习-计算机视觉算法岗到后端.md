## 1.  算法岗-技术一面

问题：因为有个cvpr，一直在问项目。

除此之外，主要围绕深度学习基本知识、BN层、如何解决泛化等

题目：手写卷积层实现方法、滑动窗口内的MAX/MEAN值

[239. 滑动窗口最大值 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/sliding-window-maximum/)

python实现，没写全，写了个大概，两层for循环说了一下结束

深度学习基础凭记忆说了大概，没准备

## 2.  算法岗-技术二面

二面开始就不太问项目了，基本上有面试官的评价作为参考。

题目：给出两个矩形的左下角和右上角坐标，返回重叠矩形的左下和右上角坐标。

python-边解释边写，两三行大概，题目可以参考--leetcode 223.矩形面积

[Loading Question... - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/rectangle-area/)

## 3.  算法岗-leeder面三面

题目：二维矩阵中，多个岛屿，对岛屿逐个进行标号

思路：基于dfs/bfs深搜，标号时注意0-1不要重复，对于方法的输入输出以及标号规则问清楚

可以参考leetcode 200. 岛屿数量 （有所不同）

[Loading Question... - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/number-of-islands/)



## 4. 算法岗-HR面

简单交流未来工作计划以及时间要求，不刷人，简单交流，基本走形式。

结束之后考虑了一下不去算法岗了，坚定转后端，hr说可以内部推荐，不需要从头来，只需要最终技术一面，继续。

## 5. 转到后端一轮挂

简历没有准备项目，直接做题

题目：给定一个二叉搜索数，写一个迭代器，能够按照升序逐个给出下一个元素，要求has_next()和next()函数时间复杂度O(1)

注意点：白板刷题，类的定义，包引用都需要额外注意。

特别注意：不要上来写类框架，先分析出思路讲出来，确认后再写，没有思路可以多问多聊（因为上来就写卡住了被批浪费彼此时间）

```
// "static void main" must be defined in a public class.
import java.util.*;

public class Main {
    public static void main(String[] args) {
        //迭代器-二叉搜索树
        class Node{
            int val;
            Node left;
            Node right;
            Node(){}
            Node(int val){this.val = val;}
        }
        
        //
        class MyIterator{
            int iter=0;
            List<Integer> middleOrder = new ArrayList<>();
            MyIterator(Node root){
                //构造函数
                dfs(root);
            }
            public void dfs(Node temp){
                if(temp==null){
                    return;
                }
                dfs(temp.left);
                //
                middleOrder.add(temp.val);
                //
                dfs(temp.right);
            }
            
            //has_next()
            public boolean has_next(){
                if(iter<middleOrder.size()){
                    return true;
                }
                else{
                    return false;
                }
            }
            public int next(){
                if(iter<middleOrder.size()){
                    int res = middleOrder.get(iter);
                    iter++;
                    return res;
                }
                else{
                    return -1;
                }
            }
        }
        
        //main主函数
        Node root = new Node(5);
        root.left = new Node(3);
        root.right = new Node(6);
        root.left.left=new Node(2);
        root.left.right=new Node(4);
        
        MyIterator myIterator = new MyIterator(root);
        
        System.out.println("start");
        boolean status = myIterator.has_next();
        System.out.println(status);
        
        System.out.println(myIterator.next());
        System.out.println(myIterator.next());
        System.out.println(myIterator.next());
        
    }
}
```

中序遍历直接保存有点暴力，可以换利用栈+下一节点的方法实现，减小空间复杂度

//注意牛客网的输入输出ACM模式

[(99+条未读通知) 牛客竞赛_ACM/NOI/CSP/CCPC/ICPC算法编程高难度练习赛_牛客竞赛OJ (nowcoder.com)](https://ac.nowcoder.com/acm/contest/5657)

```
import java.util.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNextInt()) { // 注意 while 处理多个 case
            int a = in.nextInt();
            int b = in.nextInt();
            System.out.println(a + b);
        }
    }
}
```



